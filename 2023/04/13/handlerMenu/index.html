<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Dath Chou">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Dath Chou">
    
        <meta name="keywords" content="hexo,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="首先，这篇文章会讲什么？ Android中的Handler机制，也被称为消息循环机制。它是干什么的，它由哪些东西组成，它是怎么运作的，以及面试会被怎么问。我尽力保证，通过这篇博客，配合给出的推荐文章，面试时handler相关问题就会是你的加分项。 我试着以最简单的语言去讲述我认为的最重要的东西，但这样难免出现不好理解的情况，这种时候就只能自己去搞明白了。 Let’s go then.Handl">
<meta property="og:type" content="article">
<meta property="og:title" content="Handler私房菜">
<meta property="og:url" content="https://harlequinicecream.com/2023/04/13/handlerMenu/index.html">
<meta property="og:site_name" content="三味冰淇淋">
<meta property="og:description" content="首先，这篇文章会讲什么？ Android中的Handler机制，也被称为消息循环机制。它是干什么的，它由哪些东西组成，它是怎么运作的，以及面试会被怎么问。我尽力保证，通过这篇博客，配合给出的推荐文章，面试时handler相关问题就会是你的加分项。 我试着以最简单的语言去讲述我认为的最重要的东西，但这样难免出现不好理解的情况，这种时候就只能自己去搞明白了。 Let’s go then.Handl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://harlequinicecream.com/2023/04/13/handlerMenu/cooperation.JPG">
<meta property="og:image" content="https://harlequinicecream.com/2023/04/13/handlerMenu/callback.png">
<meta property="article:published_time" content="2023-04-13T12:36:31.000Z">
<meta property="article:modified_time" content="2025-01-12T16:07:01.687Z">
<meta property="article:author" content="Dath Chou">
<meta property="article:tag" content="中文">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="人生DFS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://harlequinicecream.com/2023/04/13/handlerMenu/cooperation.JPG">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/avatar/Misaka.jpg">
    
    <title>Handler私房菜 · 三味冰淇淋</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20211217" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20211217" as="style">
    <link rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" href="/css/mobile.css?v=20211217" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20211217" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20211217" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 6.3.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>三味冰淇淋</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">三味冰淇淋</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">Handler私房菜</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
    
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                Handler私房菜
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="中文">中文</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Android">Android</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="人生DFS">人生DFS</a>
    
</div>

                
                <!-- 文章字数统计 -->
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">4k</span>阅读时长: <span class="post-count reading-time">15 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2023/04/13</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <span id="more"></span>

<p>首先，这篇文章会讲什么？</p>
<p>Android中的<strong>Handler机制</strong>，也被称为<strong>消息循环机制</strong>。它是干什么的，它由哪些东西组成，它是怎么运作的，以及<strong>面试会被怎么问</strong>。我尽力保证，通过这篇博客，配合给出的推荐文章，面试时handler相关问题就会是你的加分项。</p>
<p>我试着以最简单的语言去讲述我认为的最重要的东西，但这样难免出现不好理解的情况，这种时候就只能自己去搞明白了。</p>
<h3 id="Let’s-go-then"><a href="#Let’s-go-then" class="headerlink" title="Let’s go then."></a>Let’s go then.</h3><h2 id="Handler是做什么的？"><a href="#Handler是做什么的？" class="headerlink" title="Handler是做什么的？"></a>Handler是做什么的？</h2><p>手机上一切你能看到的东西都是要系统去绘制的，如果多线程下，每个线程都可以绘制ui，会出现多个线程同时绘制同一个ui的不可控情况，这是不可接受的。</p>
<p>那我们为什么不加锁呢？</p>
<p>太慢。UI需要以最快的速度绘制出来。</p>
<p>Handler就是为了解决这个问题，它让UI统一在主线程，有序的一个个绘制。具体来说，<strong>子线程通过持有主线程Handler的引用，使用主线程Handler进行UI绘制任务，实现子线程向主线程通信进行UI绘制。</strong></p>
<p>听不懂？没关系，先往下看。</p>
<h2 id="Handler机制成员"><a href="#Handler机制成员" class="headerlink" title="Handler机制成员"></a>Handler机制成员</h2><p>在了解Handler的运作原理之前，先来看看是什么在支撑着整套系统。</p>
<p><em>作为一个共产主义者，我想要提醒您，就像接下来要讲的几个类支撑起了Handler机制一样，不要忘记是劳动人民支撑起了一切，</em></p>
<p>在这个部分，我会将整套消息循环机制比作一个流水线工厂，帮助尚未入门的我们更好理解各部分的作用。</p>
<p>现在想象一个工厂，有一个或多个窗口，将原材料放在一个盒子里从窗口送进去，这些盒子会被送到同一个传送带上，然后依次被同一个加工机器加工，最后被送回原窗口。</p>
<ol>
<li>Handler。作为冠名整套机制的类，Handler就像这个工厂的窗口一样，往里面送入原材料，就会被加工好后送出来，再进行一系列的操作。</li>
<li>Message。流水线中的原材料不尽相同，但会被装在统一样式的盒子里。Message就是负责承载这些原材料的盒子。</li>
<li>MessageQueue。一开始说到这些装着原材料的盒子会被送到同一个传送带上，MessageQueue就是这样一个传送带，从它的名字上（消息队列）也能看出，这些Message会被送到这里来一个个被处理。</li>
<li>Looper。最后，传送带上的盒子（Message）会一个个被这台叫Looper的机器取走，加工，最后送回到它们被送进来的窗口。一条消息的循环就此完成。</li>
</ol>
<p>文字难免抽象，看看图。</p>
<p><img src="/2023/04/13/handlerMenu/cooperation.JPG" alt="cooperationg"></p>
<p>既然如此，我们只需要把主线程的窗口广而告之，所有子线程（再想象一下，这个流水线以外有许多工人，他们负责往窗口里送东西）就都可以通过向主线程的窗口里送消息了。也就是说，子线程可以向主线程通信，让主线程按照子线程的想法修改ui了。</p>
<h2 id="Handler运行原理"><a href="#Handler运行原理" class="headerlink" title="Handler运行原理"></a>Handler运行原理</h2><p>到了问题大头了，有了Handler机制的概念，那么它到底是怎么运作的呢？</p>
<p>我想把重心放在Handler的原理上，但如果你连见都没见过这套机制在代码上要怎么使用的话，光听原理可能有点空中楼阁。所以我随便搜了一套代码，来展示Handler机制的使用。</p>
<p>（这套代码为了好看，我把它改的不太好运行，所以不要尝试跑它）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerAddThreadActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button mButton;     <span class="comment">//一个要改变UI的按钮</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler; <span class="comment">//主线程Handler</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_handler_add_thread);</span><br><span class="line"></span><br><span class="line">        mButton = findViewById(xxxx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化主Handler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">                <span class="comment">//根据Message中的内容执行不同逻辑，比如改变mButton的文字</span></span><br><span class="line">                <span class="keyword">if</span>(msg.what==<span class="number">1</span>) mButton.setText(<span class="string">&quot;文案1&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> mButton.setText(<span class="string">&quot;文案2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启一个子线程</span></span><br><span class="line">        <span class="type">CustomChildThread</span> <span class="variable">customThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomChildThread</span>();</span><br><span class="line">        customThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程，用于处理耗时工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomChildThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//通过让线程睡眠一秒，来模拟一个长耗时的任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//现在长耗时任务完成了，我们想通知主线程要去修改UI了</span></span><br><span class="line">            <span class="comment">//在子线程中创建一个消息对象</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">childThreadMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">            childThreadMessage.what = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将该消息放入主线程的消息队列中</span></span><br><span class="line">            mHandler.sendMessage(childThreadMessage);</span><br><span class="line">            <span class="comment">//最后主线程Handler会处理这个Message，发现Message.what==1，</span></span><br><span class="line">            <span class="comment">//于是把按钮的文字改为&quot;文案1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们再来看看谷歌到底是怎么实现这一套充满美感的机制的。（当我们说完postDelayed()方法后，你一定会明白为什么我说它”充满美感”）</p>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>这里把Message放到第一个讲，是因为Message当中<strong>所有的属性都不依赖于别的类。换句话说，它只负责承载信息，而不实现功能。</strong> 不论是Handler，MessageQueue，还是Looper，他们实现的很多功能都要靠Message内部的属性实现。这里列出一些Message的属性，并简单解释一下它们都是做什么的。</p>
<p><em>如果你在Android Developer的官网上查找Message，会发现官网上Message的属性比起下面列出来的少了一些。事实上，官网只提供了对开发者可见的字段，但既然我们需要理解原理，自然不能止于这些。如果你有足够的好奇心，为什么不试着翻翻源码呢？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户自定义，主要用于辨别Message的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> what;</span><br><span class="line"><span class="comment">// 用于自定义存储一些整型数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> arg1;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> arg2;</span><br><span class="line"><span class="comment">// 可放入一个可序列化对象</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line"><span class="comment">// Bundle数据</span></span><br><span class="line">Bundle data;</span><br><span class="line"><span class="comment">// 以下对开发者不可见</span></span><br><span class="line"><span class="comment">// Message处理的时间。从系统开机开始算起</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> when;</span><br><span class="line"><span class="comment">// 记录这个Message是由哪个Handler发出的</span></span><br><span class="line">Handler target;</span><br><span class="line"><span class="comment">// 当Message被处理后自定义的Runnable行为</span></span><br><span class="line">Runnable callback;</span><br><span class="line"><span class="comment">// 指向MessageQueue中下一个Message</span></span><br><span class="line">Message next;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这部分比较好理解，要注意的都写在上面了。了解Message的内部结构，对于后面部分的理解有很好的帮助，比如其中的when，target，next，都是后面某些问题的答案。</p>
<p><em>我们在开头提到，Handler机制又称消息循环机制。那么现在消息有了，循环在哪呢？所以官方建议使用Message.obtain()方法去获得一个Message，而不是直接new一个，使用完之后再调用recycle()方法回收Message。上面那段代码对于Message的获取其实是不恰当的。</em></p>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>接着来看看将消息排成一列的流水线：MessageQueue，看看它有什么行为以及发挥怎样的作用。</p>
<p>MessageQueue的数据结构也不算复杂，甚至我们只需要讲一个属性，和两个方法。</p>
<p>一个属性：<code>Message mMessages;</code></p>
<p>这个属性指向当前队头的第一个消息。所以，是的，MessageQueue其实并不是一个队列，它只维护第一个Message，后面的靠Message.next属性一个一个往后指。</p>
<p><em>什么情况，就看一个属性？是的，就看一个。其余属性基本都是负责某些功能的具体实现，主要是IdleHandler，Native阻塞机制，和同步屏障机制。这些在后面都会提及，吧。</em></p>
<p>两个方法：出队<code>next()</code>和入队<code>enqueueMessage()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure>

<p><em>等等等等，别一言不合就上代码，让我先来试着简述一下。在队列里，next()方法会用一个死循环去调用队头的Message，如果这个Message的when属性，也就是这个Message应该被处理的时间，还没到的话，系统就会设置对应的堵塞时间去堵塞进程，最后进行一系列的处理（主要是和IdleHandler相关的）。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 阻塞时间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞对应时间，（-1代表永久堵塞）</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">		<span class="comment">// 对MessageQueue进行加锁，保证线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 下一个消息还没开始，记录需要堵塞的时间</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获得消息且现在要执行，标记MessageQueue为非阻塞</span></span><br><span class="line">                    <span class="comment">//注意！！该mBlocked值为全局变量，在需要堵塞的场景下该值会被设为true（相关代码牵扯到IdleHandler的内容故省略）</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 链表操作</span></span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有消息，进入阻塞状态</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点长，但其实也好理解。从队列里拿出第一个Message，看现在到不到时间执行，到时间就返回这个Message，不到时间就堵塞等待。</p>
<p><em>注意到当堵塞时间为-1时，代表着永久堵塞。那么为什么怎么做呢？什么时候唤醒呢？接着看。</em></p>
<p>说完出队的方法，再来看入队的enqueueMessage()方法。入队方法有两个参数，实际的写法是：<code>enqueueMessage(Message msg, long when)</code>。从参数名上也很容易看出来一个是要入队的消息，一个是Message应该被处理的时间。前文的Handler使用方法demo中，Handler去发送消息的sendMessage()方法，<strong>最后实际上调用enqueueMessage()方法去入队消息。</strong></p>
<p><em>还是先简述一下入队方法的逻辑。根据Message的处理时间，也就是when属性，去<strong>从头遍历消息队列</strong>，找到这个消息应该插入的位置插进去，确保整个消息队列中的消息是按处理时间排序的。再看线程是否阻塞，阻塞的话就唤醒线程。<strong>这就对应了前面说的无限阻塞的场景。</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对MessageQueue进行加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 标记Message正在被执行，将消息需要被执行的时间赋给Message.when（在此之前该属性为空）</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">// 用p记录当前队列头</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="comment">// 判断是否需要唤醒MessageQueue</span></span><br><span class="line">        <span class="comment">// 如果有新的队头，同时MessageQueue处于阻塞状态则需要唤醒队列</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            <span class="comment">//正如前文所说，mBlocked是全局变量，出队方法会改变这个变量的值。true代表正在阻塞，则需要唤醒。</span></span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 根据when找到插入的位置插入</span></span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; </span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果需要则唤醒队列</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实写到这里，我感觉有点背离初心。将四个组件分开来讲我认为是不好的，这样虽然更有条理也更容易消化，但我更想要做一个Handler机制的串讲。可能这一部分得到后面面试的部分才能实现了，如果各位看官也觉得有点不成体系的话，<strong>建议先跳过具体的代码部分，通过我的简述形成一个大致的了解，把细节问题留到最后回头看。</strong></p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>Looper的部分更好理解，关键方法也不多。正如前文所说，Looper负责不断从MessageQueue中不断取出Message，要注意的是<strong>每个线程有独立的Looper，主线程的Looper会自动准备好，而在子线程中要使用自己的Looper的话则需要调用<code>Looper.prepare()</code>方法初始化一个。</strong></p>
<p><code>Looper.prepare()</code>源码，简单看一下就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用到了这个方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便看一下Looper的构造方法。这个构造方法会同时new一个MessageQueue，并绑定当前线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像发动机需要点火来启动一样，一个Looper初始化完成后还需要调用<code>Looper.loop()</code>方法去启动这个Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的Looper与MessageQueue</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 用一个死循环去不停获取消息队列中的消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// 可能造成线程堵塞</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用Message对应的Handler（target属性）处理消息</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我把所有其余的代码都删了，只留下核心的方法，是不是难以相信的清爽？原来这么简单，就是在一个死循环里不停的获取Message，再分发到对应的Handler去处理。就是这么简单！</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>终~~~~~~~于，来到了最后的大哥，Handler。前文讲的三个组件主要是在后台默默无闻的工作着，与程序员打交道最多的还是Handler。我们用Handler去操作Message，来实现线程之间的跳跃与交流。</p>
<p>注意到创建Handler时必须显示指明对应的Looper，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.myLooper())</span><br></pre></td></tr></table></figure>

<p>对于Handler的操作主要是<strong>发送消息</strong>和<strong>处理消息</strong>，我们先从发送消息讲起。</p>
<p>发送消息的部分我不打算放代码上来了，主要是调用链比较长，每个函数内容又不多，建议参考源码。</p>
<p>发送消息最常使用的方法为<code>sendMessage(Message msg)</code>与<code>post(Runnable r)</code>，一个是直接发送消息，一个是讲Runnable包装进Message后发送。实际上这两个函数都是调用<code>sendMessageDelayed(Message msg, long delayMillis)</code>。这个函数从名字上可以看出，是实现<strong>延迟发送</strong>的功能，希望消息在delayMillis的时间后被处理。而前面两个函数既然没有说希望延迟多久发送，自然将delayMillis设为0就行了。在此之后会调用<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>函数，在此之前的delayMillis会被加上系统的开机时间，从“希望延迟的时间”转变成“会被处理的时间”后发送给MessageQueue，消息队列再调用前文说过的<code>enqueueMessage(Message msg, long when)</code>，消息最后被发送到消息队列里。</p>
<p><em>最后整理一下调用链：<code>sendMessage(Message msg)/post(Runnable r)</code>-&gt;<code>sendMessageDelayed(Message msg, long delayMillis)</code>-&gt;<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>-&gt;<code>enqueueMessage(Message msg, long when)</code></em></p>
<p>处理消息的部分显得不那么重要，主要解决的问题是由哪一层去处理消息队列下发回来的Message。一段源码，一张图可解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，以*Message.callback（也就是post方法传进去的runnale对象）-&gt;Handler.callback-&gt;Handler.handleMessage()*的顺序一层层往下看，哪一层不为空就执行哪一层，流程图如下。</p>
<p><img src="/2023/04/13/handlerMenu/callback.png" alt="图源网络，侵删致歉"></p>
<hr>
<p>终~~~~~于，四大类都讲完了，虽然我自认为已经用了很简单的文字去讲述这些内容，但付出的精力和最后产出的效果好像都不尽人意。也许以后要重新思考一下博客产出的方式，能够输出一些内容，又兼顾到自身的精力限制。<del>说白了还是太懒TT</del></p>
<p>至于前面一再说过的，我认为能称为亮点的，“面试会怎么问”的部分，我决定暂时搁置了。现在确实精力不够，等到后续我的面经整理完了，再把相关的部分更新上来。</p>
<p>好难呀，共勉。</p>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://harlequinicecream.com">Dath Chou</a>
            <p>原文链接：<a href="https://harlequinicecream.com/2023/04/13/handlerMenu/">https://harlequinicecream.com/2023/04/13/handlerMenu/</a>
            <p>发表日期：<a href="https://harlequinicecream.com/2023/04/13/handlerMenu/">April 13th 2023, 10:36:31 pm</a>
            <p>更新日期：<a href="https://harlequinicecream.com/2023/04/13/handlerMenu/">January 13th 2025, 3:07:01 am</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可，图转侵删致歉。</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2023/05/23/shittymiketea/" title="我在成都郊区的景点买了杯奥利给奶茶">
                    <div class="nextTitle">我在成都郊区的景点买了杯奥利给奶茶</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2023/04/03/mycarrdgamelife/" title="我的卡牌人生">
                    <div class="prevTitle">我的卡牌人生</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:cuisiwanf@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/cuisiwang" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/assets/weixin_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Let%E2%80%99s-go-then"><span class="toc-number">1.</span> <span class="toc-text">Let’s go then.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">Handler是做什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%9C%BA%E5%88%B6%E6%88%90%E5%91%98"><span class="toc-number"></span> <span class="toc-text">Handler机制成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">Handler运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Message"><span class="toc-number">1.</span> <span class="toc-text">Message</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MessageQueue"><span class="toc-number">2.</span> <span class="toc-text">MessageQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Looper"><span class="toc-number">3.</span> <span class="toc-text">Looper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler"><span class="toc-number">4.</span> <span class="toc-text">Handler</span></a></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 13
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2025 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span>
            <a class="archive-post-title" href="/2025/06/02/somebullshits/">2025都过了一半了</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/17</span>
            <a class="archive-post-title" href="/2025/01/17/whateverhello2025/">真的吗真的吗，我2024一年就写了一篇博客吗</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2024 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span>
            <a class="archive-post-title" href="/2024/07/23/lalalala/">转眼间2024过去不止一半了</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2023 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span>
            <a class="archive-post-title" href="/2023/12/20/ilove2023ireallydo/">ありがとう2023、そして、また。</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span>
            <a class="archive-post-title" href="/2023/11/27/daysundoing/">へいじつ</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span>
            <a class="archive-post-title" href="/2023/08/20/ohmylalaland/">おかえり</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/11</span>
            <a class="archive-post-title" href="/2023/07/11/sarabauntouchabledreamland/">年轻人的第一款提桶跑路</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span>
            <a class="archive-post-title" href="/2023/05/23/shittymiketea/">我在成都郊区的景点买了杯奥利给奶茶</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span>
            <a class="archive-post-title" href="/2023/04/13/handlerMenu/">Handler私房菜</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/03</span>
            <a class="archive-post-title" href="/2023/04/03/mycarrdgamelife/">我的卡牌人生</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span>
            <a class="archive-post-title" href="/2023/03/02/fuckoppo/">聊聊oppo，以及实习</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span>
            <a class="archive-post-title" href="/2023/02/27/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%85%A5%E9%97%A8%E3%80%8B%E7%AE%80%E8%AF%BB/">《数据压缩入门》简读</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/11</span>
            <a class="archive-post-title" href="/2023/02/11/%E5%A5%B3%E7%94%9F%E5%BE%92/">《女生徒》 ——太宰治</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="中文">
                <span class="iconfont-archer">&#xe606;</span>
                中文
            </span>
        
            <span class="sidebar-tag-name" data-tags="聊聊生活">
                <span class="iconfont-archer">&#xe606;</span>
                聊聊生活
            </span>
        
            <span class="sidebar-tag-name" data-tags="人生BFS">
                <span class="iconfont-archer">&#xe606;</span>
                人生BFS
            </span>
        
            <span class="sidebar-tag-name" data-tags="Android">
                <span class="iconfont-archer">&#xe606;</span>
                Android
            </span>
        
            <span class="sidebar-tag-name" data-tags="人生DFS">
                <span class="iconfont-archer">&#xe606;</span>
                人生DFS
            </span>
        
            <span class="sidebar-tag-name" data-tags="聊聊生活，年终总结">
                <span class="iconfont-archer">&#xe606;</span>
                聊聊生活，年终总结
            </span>
        
            <span class="sidebar-tag-name" data-tags="旅游">
                <span class="iconfont-archer">&#xe606;</span>
                旅游
            </span>
        
            <span class="sidebar-tag-name" data-tags="学习">
                <span class="iconfont-archer">&#xe606;</span>
                学习
            </span>
        
            <span class="sidebar-tag-name" data-tags="瞎写写">
                <span class="iconfont-archer">&#xe606;</span>
                瞎写写
            </span>
        
            <span class="sidebar-tag-name" data-tags="年终总结">
                <span class="iconfont-archer">&#xe606;</span>
                年终总结
            </span>
        
            <span class="sidebar-tag-name" data-tags="数据压缩">
                <span class="iconfont-archer">&#xe606;</span>
                数据压缩
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="中文">
            <span class="iconfont-archer">&#xe60a;</span>
            中文
        </span>
    
        <span class="sidebar-category-name" data-categories="学习">
            <span class="iconfont-archer">&#xe60a;</span>
            学习
        </span>
    
        <span class="sidebar-category-name" data-categories="生活">
            <span class="iconfont-archer">&#xe60a;</span>
            生活
        </span>
    
        <span class="sidebar-category-name" data-categories="Android">
            <span class="iconfont-archer">&#xe60a;</span>
            Android
        </span>
    
        <span class="sidebar-category-name" data-categories="学习">
            <span class="iconfont-archer">&#xe60a;</span>
            学习
        </span>
    
        <span class="sidebar-category-name" data-categories="阅读">
            <span class="iconfont-archer">&#xe60a;</span>
            阅读
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "https://harlequinicecream.com",
        root: siteMetaRoot,
        author: "Dath Chou"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20211217"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20211217"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20211217" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
